{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE UndecidableInstances #-}
module AbsSyntax where

import Data.Foldable

-- Haskell module generated by the BNF converter

-- | ADDED
import LexSyntax
data ASTPos = ASTPos !Int !Int !Int deriving (Eq, Show,Ord)
data ASTRef = ASTRefNone | ASTRef Int deriving (Eq, Show,Ord)
data ASTMetadata = EmptyMetadata | ASTMetadata ASTRef ASTPos deriving (Show, Eq)

class ASTMutable t where
  payloadMap :: (a -> b) -> t a -> t b
  astMap :: (Monad m) => (a -> m b) -> t a -> m (t b)
  payload :: t a -> a
  astMapShallow :: (Monad m) => (a -> m b) -> t a -> m (t b)
  astMapShallow f v = do
    a2 <- f $ payload v
    return $ payloadReplace a2 v
  payloadReplace :: a -> t b -> t a
  payloadReplace = payloadMap . const

astMapL :: (Monad m, ASTMutable t) => (a -> m b) -> [t a] -> m [t b]
astMapL f list = do
  list2 <- foldrM (\el acc -> do
   el2 <- (astMap f el)
   return $ el2:acc) [] list
  return list2

tokenMetadata :: Token -> ASTMetadata
tokenMetadata token = let (Pn i0 i1 i2) = tokenPosn token in ASTMetadata ASTRefNone (ASTPos i0 i1 i2)
-- | END ADDED

newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
newtype TypeIdentAbstract = TypeIdentAbstract String
  deriving (Eq, Ord, Show, Read)
data Program a = Program a [TopDef a]
  deriving (Eq, Ord, Show, Read)


instance ASTMutable Program where
    payloadMap f x = case x of
        Program a topdefs -> Program (f a) (map (payloadMap f) topdefs)
    astMap f (Program a topdefs) = do
        a2 <- f a
        topdefs2 <- astMapL f topdefs
        return $ Program a2 topdefs2

data TopDef a = FnDef a (TypeName a) Ident [Arg a] (Block a)
  deriving (Eq, Ord, Show, Read)

instance ASTMutable TopDef where
    payloadMap f x = case x of
        FnDef a typename ident args block -> FnDef (f a) (payloadMap f typename) ident (map (payloadMap f) args) (payloadMap f block)
    astMap f (FnDef a typename ident args block) = do
        a2 <- f a
        typename2 <- astMap f typename
        block2 <- astMap f block
        args2 <- astMapL f args
        return $ FnDef a2 typename2 ident args2 block2
    payload (FnDef a _ _ _ _) = a

data Arg a = Arg a (TypeName a) Ident
  deriving (Eq, Ord, Show, Read)

instance ASTMutable Arg where
    payloadMap f x = case x of
        Arg a typename ident -> Arg (f a) (payloadMap f typename) ident
    astMap f (Arg a typename ident) = do
        a2 <- f a
        typename2 <- astMap f typename
        return $ Arg a2 typename2 ident
    payload (Arg a _ _) = a

data Block a = Block a [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance ASTMutable Block where
    payloadMap f x = case x of
        Block a stmts -> Block (f a) (map (payloadMap f) stmts)
    astMap f (Block a stmts) = do
        a2 <- f a
        stmts2 <- astMapL f stmts
        return $ Block a2 stmts2
    payload (Block a _) = a

data Stmt a
    = Empty a
    | BStmt a (Block a)
    | Decl a (TypeName a) [Item a]
    | Ass a Ident (Expr a)
    | Incr a Ident
    | Decr a Ident
    | Ret a (Expr a)
    | VRet a
    | Cond a (Expr a) (Stmt a)
    | CondElse a (Expr a) (Stmt a) (Stmt a)
    | While a (Expr a) (Stmt a)
    | SExp a (Expr a)
  deriving (Eq, Ord, Show, Read)

instance ASTMutable Stmt where
    payloadMap f x = case x of
        Empty a -> Empty (f a)
        BStmt a block -> BStmt (f a) (payloadMap f block)
        Decl a typename items -> Decl (f a) (payloadMap f typename) (map (payloadMap f) items)
        Ass a ident expr -> Ass (f a) ident (payloadMap f expr)
        Incr a ident -> Incr (f a) ident
        Decr a ident -> Decr (f a) ident
        Ret a expr -> Ret (f a) (payloadMap f expr)
        VRet a -> VRet (f a)
        Cond a expr stmt -> Cond (f a) (payloadMap f expr) (payloadMap f stmt)
        CondElse a expr stmt1 stmt2 -> CondElse (f a) (payloadMap f expr) (payloadMap f stmt1) (payloadMap f stmt2)
        While a expr stmt -> While (f a) (payloadMap f expr) (payloadMap f stmt)
        SExp a expr -> SExp (f a) (payloadMap f expr)
    astMap f (Empty a) = do
        a2 <- f a
        return $ Empty a2
    astMap f (BStmt a block) = do
        a2 <- f a
        block2 <- astMap f block
        return $ BStmt a2 block2
    astMap f (Decl a typename items) = do
        a2 <- f a
        typename2 <- astMap f typename
        items2 <- astMapL f items
        return $ Decl a2 typename2 items2
    astMap f (Ass a ident expr) = do
        a2 <- f a
        expr2 <- astMap f expr
        return $ Ass a2 ident expr2
    astMap f (Incr a ident) = do
        a2 <- f a
        return $ Incr a2 ident
    astMap f (Decr a ident) = do
        a2 <- f a
        return $ Decr a2 ident
    astMap f (Ret a expr) = do
        a2 <- f a
        expr2 <- astMap f expr
        return $ Ret a2 expr2
    astMap f (VRet a) = do
        a2 <- f a
        return $ VRet a2
    astMap f (Cond a expr stmt) = do
        a2 <- f a
        expr2 <- astMap f expr
        stmt2 <- astMap f stmt
        return $ Cond a2 expr2 stmt2
    astMap f (CondElse a expr stmtA stmtB) = do
        a2 <- f a
        expr2 <- astMap f expr
        stmtA2 <- astMap f stmtA
        stmtB2 <- astMap f stmtB
        return $ CondElse a2 expr2 stmtA2 stmtB2
    astMap f (While a expr stmt) = do
        a2 <- f a
        expr2 <- astMap f expr
        stmt2 <- astMap f stmt
        return $ While a2 expr2 stmt2
    astMap f (SExp a exp) = do
        a2 <- f a
        exp2 <- astMap f exp
        return $ SExp a2 exp2
    payload x = case x of
        Empty a -> a
        BStmt a _ -> a
        Decl a _ _ -> a
        Ass a _ _ -> a
        Incr a _ -> a
        Decr a _ -> a
        Ret a _ -> a
        VRet a -> a
        Cond a _ _ -> a
        CondElse a _ _ _ -> a
        While a _ _ -> a
        SExp a _ -> a

data Item a = NoInit a Ident | Init a Ident (Expr a)
  deriving (Eq, Ord, Show, Read)

instance ASTMutable Item where
    payloadMap f x = case x of
        NoInit a ident -> NoInit (f a) ident
        Init a ident expr -> Init (f a) ident (payloadMap f expr)
    astMap f (NoInit a ident) = do
        a2 <- f a
        return $ NoInit a2 ident
    astMap f (Init a ident expr) = do
        a2 <- f a
        expr2 <- astMap f expr
        return $ Init a2 ident expr2
    payload x = case x of
        NoInit a _ -> a
        Init a _ _ -> a

data TypeName a = Int a | Str a | Bool a | Void a
  deriving (Eq, Ord, Show, Read)

instance ASTMutable TypeName where
    payloadMap f x = case x of
        Int a -> Int (f a)
        Str a -> Str (f a)
        Bool a -> Bool (f a)
        Void a -> Void (f a)
    payload x = case x of
        Int a -> a
        Str a -> a
        Bool a -> a
        Void a -> a
    astMap = astMapShallow

data TypName a = Fun a (TypeName a) [TypeName a]
  deriving (Eq, Ord, Show, Read)

instance ASTMutable TypName where
    payloadMap f x = case x of
        Fun a typename typenames -> Fun (f a) (payloadMap f typename) (map (payloadMap f) typenames)
    payload x = case x of
         Fun a _ _ -> a
    astMap f (Fun a typename typenames) = do
      a2 <- f a
      typename2 <- astMap f typename
      typenames2 <- astMapL f typenames
      return $ Fun a2 typename2 typenames2

data Expr a
    = EVar a Ident
    | ELitInt a Integer
    | ELitTrue a
    | ELitFalse a
    | EApp a Ident [Expr a]
    | EString a String
    | Neg a (Expr a)
    | Not a (Expr a)
    | EMul a (Expr a) (MulOp a) (Expr a)
    | EAdd a (Expr a) (AddOp a) (Expr a)
    | ERel a (Expr a) (RelOp a) (Expr a)
    | EAnd a (Expr a) (Expr a)
    | EOr a (Expr a) (Expr a)
  deriving (Eq, Ord, Show, Read)

instance ASTMutable Expr where
    payloadMap f x = case x of
        EVar a ident -> EVar (f a) ident
        ELitInt a integer -> ELitInt (f a) integer
        ELitTrue a -> ELitTrue (f a)
        ELitFalse a -> ELitFalse (f a)
        EApp a ident exprs -> EApp (f a) ident (map (payloadMap f) exprs)
        EString a string -> EString (f a) string
        Neg a expr -> Neg (f a) (payloadMap f expr)
        Not a expr -> Not (f a) (payloadMap f expr)
        EMul a expr1 mulop expr2 -> EMul (f a) (payloadMap f expr1) (payloadMap f mulop) (payloadMap f expr2)
        EAdd a expr1 addop expr2 -> EAdd (f a) (payloadMap f expr1) (payloadMap f addop) (payloadMap f expr2)
        ERel a expr1 relop expr2 -> ERel (f a) (payloadMap f expr1) (payloadMap f relop) (payloadMap f expr2)
        EAnd a expr1 expr2 -> EAnd (f a) (payloadMap f expr1) (payloadMap f expr2)
        EOr a expr1 expr2 -> EOr (f a) (payloadMap f expr1) (payloadMap f expr2)
    astMap f (EVar a ident) = do
        a2 <- f a
        return $ EVar a2 ident
    astMap f (ELitInt a integer) = do
        a2 <- f a
        return $ ELitInt a2 integer
    astMap f (ELitTrue a) = do
        a2 <- f a
        return $ ELitTrue a2
    astMap f (ELitFalse a) = do
        a2 <- f a
        return $ ELitFalse a2
    astMap f (EApp a ident exprs) = do
        a2 <- f a
        exprs2 <- astMapL f exprs
        return $ EApp a2 ident exprs2
    astMap f (EString a string) = do
        a2 <- f a
        return $ EString a2 string
    astMap f (Neg a expr) = do
        a2 <- f a
        expr2 <- astMap f expr
        return $ Neg a2 expr2
    astMap f (Not a expr) = do
        a2 <- f a
        expr2 <- astMap f expr
        return $ Not a2 expr2
    astMap f (EMul a exprA mulop exprB) = do
        a2 <- f a
        exprA2 <- astMap f exprA
        mulop2 <- astMap f mulop
        exprB2 <- astMap f exprB
        return $ EMul a2 exprA2 mulop2 exprB2
    astMap f (EAdd a exprA mulop exprB) = do
        a2 <- f a
        exprA2 <- astMap f exprA
        mulop2 <- astMap f mulop
        exprB2 <- astMap f exprB
        return $ EAdd a2 exprA2 mulop2 exprB2
    astMap f (ERel a exprA mulop exprB) = do
        a2 <- f a
        exprA2 <- astMap f exprA
        mulop2 <- astMap f mulop
        exprB2 <- astMap f exprB
        return $ ERel a2 exprA2 mulop2 exprB2
    astMap f (EAnd a exprA exprB) = do
         a2 <- f a
         exprA2 <- astMap f exprA
         exprB2 <- astMap f exprB
         return $ EAnd a2 exprA2 exprB2
    astMap f (EOr a exprA exprB) = do
         a2 <- f a
         exprA2 <- astMap f exprA
         exprB2 <- astMap f exprB
         return $ EOr a2 exprA2 exprB2
    payload x = case x of
        EVar a _ -> a
        ELitInt a _ -> a
        ELitTrue a -> a
        ELitFalse a -> a
        EApp a _ _ -> a
        EString a _ -> a
        Neg a _ -> a
        Not a _ -> a
        EMul a _ _ _ -> a
        EAdd a _ _ _ -> a
        ERel a _ _ _ -> a
        EAnd a _ _ -> a
        EOr a _ _ -> a

data AddOp a = Plus a | Minus a
  deriving (Eq, Ord, Show, Read)

instance ASTMutable AddOp where
    payloadMap f x = case x of
        Plus a -> Plus (f a)
        Minus a -> Minus (f a)
    astMap = astMapShallow
    payload x = case x of
        Plus a -> a
        Minus a -> a

data MulOp a = Times a | Div a | Mod a
  deriving (Eq, Ord, Show, Read)

instance ASTMutable MulOp where
    payloadMap f x = case x of
        Times a -> Times (f a)
        Div a -> Div (f a)
        Mod a -> Mod (f a)
    astMap = astMapShallow
    payload x = case x of
        Times a -> a
        Div a -> a
        Mod a -> a

data RelOp a = LTH a | LE a | GTH a | GE a | EQU a | NE a
  deriving (Eq, Ord, Show, Read)

instance ASTMutable RelOp where
    payloadMap f x = case x of
        LTH a -> LTH (f a)
        LE a -> LE (f a)
        GTH a -> GTH (f a)
        GE a -> GE (f a)
        EQU a -> EQU (f a)
        NE a -> NE (f a)
    astMap = astMapShallow
    payload x = case x of
        LTH a -> a
        LE a -> a
        GTH a -> a
        GE a -> a
        EQU a -> a
        NE a -> a
data TypeParam a
    = TypeParamJust a [TypeIdentAbstract]
    | TypeParamJustOne a TypeIdentAbstract
    | TypeParamNone a
  deriving (Eq, Ord, Show, Read)

instance ASTMutable TypeParam where
    payloadMap f x = case x of
        TypeParamJust a typeidentabstracts -> TypeParamJust (f a) typeidentabstracts
        TypeParamJustOne a typeidentabstract -> TypeParamJustOne (f a) typeidentabstract
        TypeParamNone a -> TypeParamNone (f a)
    astMap f (TypeParamJust a typeidentabstracts) = do
      a2 <- f a
      return $ TypeParamJust a2 typeidentabstracts
    astMap f (TypeParamJustOne a typeidentabstract) = do
      a2 <- f a
      return $ TypeParamJustOne a2 typeidentabstract
    astMap f v@(TypeParamNone a) = astMapShallow f v
    payload x = case x of
      TypeParamJust a _ -> a
      TypeParamJustOne a _ -> a
      TypeParamNone a -> a

data TypeArgEl a = TypeArgEl a (TypeExpression a)
  deriving (Eq, Ord, Show, Read)

instance ASTMutable TypeArgEl where
    payloadMap f x = case x of
        TypeArgEl a typeexpression -> TypeArgEl (f a) (payloadMap f typeexpression)
    astMap f (TypeArgEl a typeexpression) = do
        a2 <- f a
        typeexpression2 <- astMap f typeexpression
        return $ TypeArgEl a2 typeexpression2
    payload x = case x of
        TypeArgEl a _ -> a

data TypeArg a
    = TypeArgJust a (TypeArgEl a) [TypeArgEl a]
    | TypeArgJustOne a (TypeSimpleExpression a)
  deriving (Eq, Ord, Show, Read)

instance ASTMutable TypeArg where
    payloadMap f x = case x of
        TypeArgJust a typeargel typeargels -> TypeArgJust (f a) (payloadMap f typeargel) (map (payloadMap f) typeargels)
        TypeArgJustOne a typesimpleexpression -> TypeArgJustOne (f a) (payloadMap f typesimpleexpression)
    astMap f (TypeArgJust a typeargel typeargels) = do
        a2 <- f a
        typeargel2 <- astMap f typeargel
        typeargels2 <- astMapL f typeargels
        return $ TypeArgJust a2 typeargel2 typeargels2
    astMap f (TypeArgJustOne a typesimpleexpression) = do
        a2 <- f a
        typesimpleexpression2 <- astMap f typesimpleexpression
        return $ TypeArgJustOne a2 typesimpleexpression2
    payload x = case x of
        TypeArgJust a _ _ -> a
        TypeArgJustOne a _ -> a
        
data TypeSimpleExpression a
    = TypeSExprEmpty a
    | TypeSExprAbstract a TypeIdentAbstract
    | TypeSExprIdent a Ident
    | TypeSExprList a (TypeExpression a)
  deriving (Eq, Ord, Show, Read)

instance ASTMutable TypeSimpleExpression where
    payloadMap f x = case x of
        TypeSExprEmpty a -> TypeSExprEmpty (f a)
        TypeSExprAbstract a typeidentabstract -> TypeSExprAbstract (f a) typeidentabstract
        TypeSExprIdent a ident -> TypeSExprIdent (f a) ident
        TypeSExprList a typeexpression -> TypeSExprList (f a) (payloadMap f typeexpression)
    astMap f v@(TypeSExprEmpty a) = astMapShallow f v
    astMap f (TypeSExprAbstract a typeidentabstract) = do
        a2 <- f a
        return $ TypeSExprAbstract a2 typeidentabstract
    astMap f (TypeSExprIdent a ident) = do
        a2 <- f a
        return $ TypeSExprIdent a2 ident
    astMap f (TypeSExprList a typeexpression) = do
        a2 <- f a
        typeexpression2 <- astMap f typeexpression
        return $ TypeSExprList a2 typeexpression2
    payload x = case x of
        TypeSExprEmpty a -> a
        TypeSExprAbstract a _ -> a
        TypeSExprIdent a _ -> a
        TypeSExprList a _ -> a

data TypeExpression a
    = TypeExprSimple a (TypeSimpleExpression a)
    | TypeExprIdent a (TypeArg a) Ident
    | TypeExprTuple a (TypeExpression a) [TypeExpression a]
    | TypeFun a (TypeExpression a) (TypeExpression a)
  deriving (Eq, Ord, Show, Read)

instance ASTMutable TypeExpression where
    payloadMap f x = case x of
        TypeExprSimple a typesimpleexpression -> TypeExprSimple (f a) (payloadMap f typesimpleexpression)
        TypeExprIdent a typearg ident -> TypeExprIdent (f a) (payloadMap f typearg) ident
        TypeExprTuple a typeexpression typeexpressions -> TypeExprTuple (f a) (payloadMap f typeexpression) (map (payloadMap f) typeexpressions)
        TypeFun a typeexpression1 typeexpression2 -> TypeFun (f a) (payloadMap f typeexpression1) (payloadMap f typeexpression2)
    astMap f (TypeExprSimple a typesimpleexpression) = do
        a2 <- f a
        typesimpleexpression2 <- astMap f typesimpleexpression
        return $ TypeExprSimple a2 typesimpleexpression2
    astMap f (TypeExprIdent a typearg ident) = do
        a2 <- f a
        typearg2 <- astMap f typearg
        return $ TypeExprIdent a2 typearg2 ident
    astMap f (TypeExprTuple a typeexpression typeexpressions) = do
        a2 <- f a
        typeexpression2 <- astMap f typeexpression
        typeexpressions2 <- astMapL f typeexpressions
        return $ TypeExprTuple a2 typeexpression2 typeexpressions2
    astMap f (TypeFun a typeexpressionA typeexpressionB) = do
        a2 <- f a
        typeexpressionA2 <- astMap f typeexpressionA
        typeexpressionB2 <- astMap f typeexpressionB
        return $ TypeFun a2 typeexpressionA2 typeexpressionB2
    payload x = case x of
        TypeExprSimple a _ -> a
        TypeExprIdent a _ _ -> a
        TypeExprTuple a _ _ -> a
        TypeFun a _ _ -> a

data TypeConstraint a
    = TypeConstrDef a (TypeExpression a) | TypeConstrEmpty a
  deriving (Eq, Ord, Show, Read)

instance ASTMutable TypeConstraint where
    payloadMap f x = case x of
        TypeConstrDef a typeexpression -> TypeConstrDef (f a) (payloadMap f typeexpression)
        TypeConstrEmpty a -> TypeConstrEmpty (f a)
    astMap f (TypeConstrDef a typeexpression) = do
        a2 <- f a
        typeexpression2 <- astMap f typeexpression
        return $ TypeConstrDef a2 typeexpression2
    astMap f v@(TypeConstrEmpty a) = astMapShallow f v
    payload x = case x of
        TypeConstrDef a _ -> a
        TypeConstrEmpty a -> a

data ASTNode a
    = ASTProgram a (Program a)
    | ASTExpr a (Expr a)
    | ASTStmt a (Stmt a)
    | ASTBlock a (Block a)
    | ASTTopDef a (TopDef a)
    | ASTTypeName a (TypeName a)
    | ASTItem a (Item a)
    | ASTNone a
  deriving (Eq, Ord, Show, Read)

instance ASTMutable ASTNode where
    payloadMap f x = case x of
        ASTProgram a program -> ASTProgram (f a) (payloadMap f program)
        ASTExpr a expr -> ASTExpr (f a) (payloadMap f expr)
        ASTStmt a stmt -> ASTStmt (f a) (payloadMap f stmt)
        ASTBlock a block -> ASTBlock (f a) (payloadMap f block)
        ASTTopDef a topdef -> ASTTopDef (f a) (payloadMap f topdef)
        ASTTypeName a typename -> ASTTypeName (f a) (payloadMap f typename)
        ASTItem a item -> ASTItem (f a) (payloadMap f item)
        ASTNone a -> ASTNone (f a)
    astMap f v = astMapShallow f v
    payload x = case x of
        ASTProgram a _ -> a
        ASTExpr a _ -> a
        ASTStmt a _ -> a
        ASTBlock a _ -> a
        ASTTopDef a _ -> a
        ASTTypeName a _ -> a
        ASTItem a _ -> a
        ASTNone a -> a

